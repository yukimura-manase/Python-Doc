
< Pythonでできること >

Webアプリ開発 => フレームワークは「 Django 」や「 Flask 」

機械学習

---------------------------------------------------------------------------------------------------------------------------------------

< Python環境構築 >

python --version

Pythonのバージョンのうち、バージョンを表す数字が「2」から始まるものを「2系」と呼びます。現在、Pythonではバージョンが「3」から始まる「3系」と呼ばれるものも存在します。

Pythonの場合、「2系」と「3系」は異なっている部分が多く、コードの書き方も違います。

Progateで学習した書き方は主に「3系」に対応していますので、特に理由がない場合には「3系」を利用するようにしましょう。

それでは次の章から、「pyenv」(パイエンブ)というツールを用いて、「3系」のPythonをインストールする方法を順に学習していきます。

「pyenv」の特徴として、「複数のバージョンのPythonを管理できる」という点があります。これまでに見てきたように、Pythonにはいくつものバージョンがあります。

pyenv を使うと、1 台のパソコンで複数バージョンの python 環境を簡単に切り替えることができる。

今後Pythonでの開発を進めていく中で、異なるバージョンのPythonを使用したくなったり、複数のバージョンを用いる必要がでてくるでしょう。

今後の開発を楽にするためにも、少し時間はかかりますが「pyenv」を用いた環境構築方法を学習していきましょう！

# インストールできる一覧
pyenv install --list

# pyenvを使ったPythonインストール
pyenv install 3.6.5(バージョン番号)

pyenv install でエラーが出た時の対処法
https://harucharuru.hatenablog.com/entry/2020/11/16/205232

# 上記でエラーが出る場合の対処法(2021/12/1時点)
LDFLAGS="-L$(xcrun --show-sdk-path)/usr/lib" pyenv install 3.9.0(バージョン番号)

pyenv versions

# グローバル設定
pyenv global 3.9.0(バージョン番号)


# Pythonのグローバル設定確認
python --version または python -V (大文字)

pyenv の使い方: Python をインストールした後でバージョンが適用されない場合の対処法（Mac / Windows）
https://commte.net/7259

  1. echo $SHELL

  // zshの場合
  2. eval "$(pyenv init -)"

     export PYENV_ROOT="$HOME/.pyenv"
     
     export PATH="$PYENV_ROOT/bin:$PATH"
     
     eval "$(pyenv init --path)"

  3. python -V
    で反映を確認



Pythonの開発環境を用意しよう！（Mac）
https://prog-8.com/docs/python-env


(macOS)pyenvとPython3.9をインストールする
https://it-jog.com/py/intro/pyenvsetting#pyenvsetting


pyenvでpythonのビルドに失敗する（MacOS / Big Sur）
https://zenn.dev/ytkhs/scraps/f06b54d7f6abd1

---------------------------------------------------------------------------------------------------------------------------------------

< Pythonの基礎学習 >

Pythonはシンプルで英語に近く、理解しやすいプログラミング言語です。

Pythonを使うとWebアプリケーション開発や機械学習、統計処理などといった様々なことが可能になります。

GoogleやFacebookなどのトップIT企業でも開発言語として採用されています。

---------------------------------------------------------------------------------------------------------------------------------------

< Pythonで出力 >

① printメソッド => データの出力

# 数値の 7 を出力してください
print(7)

# 9 に 3 足した値を出力してください
print(9 + 3)

# 「 9 + 3 」を文字列として出力してください
print("9 + 3")

---------------------------------------------------------------------------------------------------------------------------------------

< 変数の定義 >

① 変数の定義 => 「変数名 = 値」

「変数」について学習します。

変数とは、データ（値）を入れておく箱のようなものです。

この箱（変数）に名前（変数名）をつけることで、その名前を用いて変数に値を入れることや、変数から値を取り出すことができます。


変数は下図のように「変数名 = 値」で定義します。変数名はクォーテーションで囲む必要はありません。
また、プログラミングの「=」は「等しい」という意味ではなく、「右辺を左辺に代入する」という意味になるので覚えておきましょう。

name = "ロボ玉"

print(name) // ロボ玉

number = 7

# 変数 number の値を出力してください
print(number) // 7

変数名は、スネークケースはOK！

user_name = "ロボ玉試作1号機"

print(user_name)


< 変数を使う意義 >

変数を使うメリットの1つは、データに名前をつけることで、扱っているデータの中身が何を表しているのかが明確になることです。


1. 同じデータを繰り返し利用することができる
2. 変数の値に変更が必要になった場合、変更する箇所が1箇所で済む


apple_price = 200
apple_count = 8

# apple_price と apple_count を掛けた結果を、変数 total_price に代入してください
total_price = apple_price * apple_count

# total_price の値を出力してください
print(total_price)


< 変数の値を更新する >

一度定義した変数の値を更新してみましょう。
「変数名 = 新しい値」とすることで変数の値を上書きすることができます。

---------------------------------------------------------------------------------------------------------------------------------------

< 型変換(データ型を変換するメソッド) >

str()メソッド => 文字列型に変換する

int()メソッド

---------------------------------------------------------------------------------------------------------------------------------------

< 条件分岐 >
条件式の中では、２つの値を比較するための記号「比較演算子」がよく使われます。まずは左図の2つを覚えましょう。

if文の条件部分は右図のように「if 条件式 :」のように書きます。

インデント => if文の条件式が成立した時の処理を書くときには、インデント（字下げ）をします。

x = 7 * 10
y = 5 * 6

# x が 70 と等しい場合に「 xは70です 」と出力してください
if x == 70 :
  print('xは70です')


# y が 40 と等しくない場合に「 yは40ではありません 」と出力してください
if y != 40 :
  print('yは40ではありません')


apple_price = 200
# 変数 money に数値 1000 を代入してください
money = 1000

input_count = input('購入するりんごの個数を入力してください：')
count = int(input_count)
total_price = apple_price * count

print('購入するりんごの個数は' + str(count) + '個です')
print('支払い金額は' + str(total_price) + '円です')

# money と total_price の比較結果によって条件を分岐してください

if money > total_price :
  print('りんごを'+ str(count) + '個買いました')
  print('残金は'+ str(money - total_price) +'円です')
elif money == total_price :
  print('りんごを'+ str(count) + '個買いました')
  print('財布が空になりました')
else :
  print('お金が足りません')
  print('りんごを買えませんでした')

---------------------------------------------------------------------------------------------------------------------------------------


< 真偽値型 >
真偽値を扱うデータ型、「真偽値型」には「True」と「False」という2つの値が存在します。

---------------------------------------------------------------------------------------------------------------------------------------

< inputメソッド >
コンソールからの入力を受け取ることができる！

---------------------------------------------------------------------------------------------------------------------------------------
< リスト >

JSで言うところの配列

複数のデータをまとめて管理するにはリストというものを用います。

リストは[要素1, 要素2, ...]のように作ります。リストに入っているそれぞれの値のことを要素と呼びます。

リストを使うと、複数の文字列や複数の数値を1つのものとして管理することができます。

リストを変数に代入しよう

リストも1つの値なので変数に代入することができます。

このとき、リストを代入する変数名は慣習上複数形にすることが多いので、覚えておきましょう。

リストの要素を取得しよう

リストの要素には、前から順に「0, 1, 2,・・・」と数字が割り振られています。これをインデックス番号といいます。

インデックス番号は0から始まる点に注意してください。

リストの各要素は、リスト[インデックス番号]とすることで取得することができます。


# 変数 fruits に、複数の文字列を要素に持つリストを代入してください
fruits = ['apple','banana','orange']

# インデックス番号が 0 の要素を出力してください
print(fruits[0])

# インデックス番号が 2 の要素を文字列と連結して出力してください
print('好きな果物は'+ fruits[2] +'です')


リストの要素を更新しよう

リストの要素を更新してみましょう。

「リスト[インデックス番号] = 値」とすることで、リストの指定したインデックス番号の要素を更新することができます。

リストに要素を追加しよう
リストには、新しく要素を追加することもできます。

「リスト.append(値)」とすることで、すでに定義されているリストの末尾に新たな要素を追加することができます。

fruits = ['apple', 'banana', 'orange']

# リストの末尾に文字列「 grape 」を追加してください
fruits.append('grape')

# 変数 fruits に代入したリストを出力してください
print(fruits)

# インデックス番号が 0 の要素を文字列「 cherry 」に更新してください
fruits[0] = 'cherry'

# インデックス番号が 0 の要素を出力してください
print(fruits[0])



---------------------------------------------------------------------------------------------------------------------------------------

< for文・繰り返し処理 >

リストの要素を
全て取得しよう
リストの要素を全て出力したいような時、左の図のように書くのは非常に面倒です。
for文というものを使うと、これを簡単にできるようになります。
次のスライドでfor文について見ていきましょう。

for文を使うと、リストの要素を順に取り出して処理を行うことができます。
下図のように「for 変数名 in リスト:」と書くことで、リストの要素の数だけ、処理を繰り返すことができます。
詳しい処理の流れは次のスライドで確認しましょう。

「for 変数名 in リスト:」とすると変数には、リストの要素が先頭から順に1つずつ入っていき、その上でfor文の中の処理が実行されます。処理はリストの要素の数だけ繰り返し行われます（繰り返し処理）。
また、変数名は自由ですが、リスト名の単数形にすることが慣習上多いです。

< リストでのfor文 >
fruits = ['apple', 'banana', 'orange']

# for 文を用いてリストの要素を1つずつ取り出し、「 好きな果物は◯◯です 」と出力してください
for fruit in fruits :
    print('好きな果物は'+ fruit +'です')


fruitsに代入されている配列の要素を、1つずつfruitに代入するには、以下のようにします。
for fruit in fruits:

---------------------------------------------------------------------------------------------------------------------------------------

< 辞書(key&value型) >

JSで言うところのオブジェクト

辞書は、リストと同じように複数のデータをまとめて管理するのに用いられます。

リストとの違いは、個々の要素をインデックス番号ではなくキーと呼ばれる名前を付けて管理する点です。

辞書ではキーと値のペアが1つの要素となります。

辞書は{キー1: 値1, キー2: 値2, …}のように作ります。

ほとんどの場合、キーには文字列が使われます。

リストは要素を[]で囲みましたが、辞書は{}で囲みます。キーと値の間はコロン（:）、要素同士の間はコンマ（,）で区切ります。

辞書の要素の順番

辞書内の要素には順序がないことに気をつけましょう。
*Python 3.7以降はキーの順序を保証するようになりました。

辞書の要素の取り出し方
辞書の値を取り出すには、取り出したい値に対応する「キー」を用いて辞書名[キー]のように書きます。


# 変数 fruits に辞書を代入してください
fruits = {
    'apple':'りんご',
    'banana':'バナナ'
}

# 辞書 fruits のキー「 banana 」に対応する値を出力してください
print(fruits['banana'])

# 辞書 fruits を用いて、「 appleは◯◯という意味です 」となるように出力してください
print('appleは'+ fruits['apple'] +'という意味です')

---------------------------------------------------------------------------------------------------------------------------------------

辞書の要素を更新しよう

辞書はリストと同じように要素の更新と追加をすることができます。

まずは要素の変更をしてみましょう。

「 辞書名[キー名] = 値 」と書くことで要素の更新をすることができます。

辞書に要素を追加しよう

「 辞書名[新しいキー名] = 値 」
と書くことで辞書に新しい要素を追加することができます。

ただし、辞書にすでにあるキー名を指定すると、値の追加ではなく更新になってしまうので注意しましょう。


fruits = {'apple': 100, 'banana': 200, 'orange': 400}

# キー「 banana 」の値を数値 300 に更新してください
fruits['banana'] = 300

# キーが「 grape 」、値が数値の 500 の要素を辞書 fruits に追加してください
fruits['grape'] = 500

# fruits の値を出力してください
print(fruits)



---------------------------------------------------------------------------------------------------------------------------------------

< 辞書でのfor文 >

辞書の要素をすべて取得しよう！

リストと同じように、辞書もfor文を用いて要素を1つずつ取り出し、処理を行うことができます。

「 for 変数名 in 辞書: 」
と書くことで繰り返し処理をすることができます。

ここで定義された変数にそれぞれの要素のキーが1つずつ代入されます。

fruits = {'apple': 'りんご', 'banana': 'バナナ', 'grape': 'ぶどう'}

# for 文を用いて、辞書のキーを1つずつ取り出し、繰り返しの中で「 ◯◯は△△という意味です 」と出力させてください
for fruit_key in fruits :
    print( fruit_key +'は'+ fruits[fruit_key] +'という意味です')

---------------------------------------------------------------------------------------------------------------------------------------

< while文 >

繰り返し処理にはfor文以外にもwhile文というものがあります。

while文を用いると、「ある条件に当てはまる間、処理を繰り返す」といったことが可能になります。

次のスライドでwhile文の書き方を見ていきましょう。

while文の処理の流れを見てみましょう。

まずwhile文の前で変数を定義します。

この変数をwhile文の条件式で用い、処理を繰り返すかどうか判断します。

while文内の処理が一周終わると、その度に変数は更新され、再び条件式がチェックされます。

Trueであればもう一周処理を行い、Falseであれば繰り返しを終了します。

繰り返し処理では、必ずどこかで条件がFalseになるように実装 => 無限ループを防止する！

x = 10

# while 文を用いて、「変数 x が 0 より大きい」間、繰り返される繰り返し処理を作ってください
while 0 < x :
    # 変数 x を出力してください
    print(x)
    # 変数 x から 1 引いてください
    x = x - 1

---------------------------------------------------------------------------------------------------------------------------------------

< break文 (強制終了) >


ここでは繰り返し処理を繰り返しの途中で強制的に終了するための方法を学びましょう。

breakを用いると繰り返し処理を終了することができます。下図のようにif文などの条件分岐と組み合わせて使います。

while文でも同じように使うことができます。


numbers = [765, 921, 777, 256]
for number in numbers:
    print(number)
    # 変数 number が 777 のとき「 777が見つかったので処理を終了します 」と出力した後、処理を終了させてください
    if number == 777 :
        print('777が見つかったので処理を終了します')
        break


---------------------------------------------------------------------------------------------------------------------------------------

< continue文 (スキップして継続) >


繰り返し処理を終了するbreakと違い、continueはその周の処理だけをスキップすることができます。

continueもif文などと組み合わせて利用します。

while文でも同じように使うことができます。


numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for number in numbers:
    # 変数 number の値が 3 の倍数のとき、繰り返し処理をスキップしてください
    if number % 3 == 0 :
        continue
    
    print(number)



---------------------------------------------------------------------------------------------------------------------------------------

< 関数 >

「関数」とは、ある処理をまとめたプログラムの塊で、printも関数の1つです。

関数を作ってみよう

まずは関数の作り方について学習していきましょう。

関数は「def 関数名():」のように定義します。

def 関数名() :
  処理内容

# 関数の定義
def Robotama() :
  print("ロボ玉")

# 関数の呼び出し
Robotama()

関数の処理の内容は、下図のようにインデントして書いていきます。


# 引数を受け取れるようにしてください
def print_hand(hand):
    # 「 ◯◯を出しました 」と出力されるように書き換えてください
    print(hand + 'を出しました')

# 引数に文字列「 グー 」を入れてください
print_hand('グー')

# 引数を文字列「 パー 」として関数 print_hand を呼び出してください
print_hand('パー')


引数の初期値

引数には初期値を設定することもできます。

引数が省略されたとき、初期値が与えられていれば代わりの値として初期値が使われます。

# 仮引数 name の初期値を設定してください
def print_hand(hand, name = 'ゲスト'):
    print(name + 'は' + hand + 'を出しました')

# 引数に文字列「 グー 」のみを入れてください
print_hand('グー')


---------------------------------------------------------------------------------------------------------------------------------------

< 戻り値とは >

戻り値とは

関数validateは「1」を受け取ると、処理結果の「True」を呼び出し元に返します。

この「True」にあたるのが戻り値です。

「return 戻り値」と書くことで戻り値を呼び出し元に返すことができます。

returnは戻り値を呼び出し元に返すだけでなく、関数内の処理を終了させる性質も持っています。

よって、return以降の関数の処理が実行されることはありません。


---------------------------------------------------------------------------------------------------------------------------------------


< じゃんけんゲーム >

def validate(hand):
    if hand < 0 or hand > 2:
        return False
    return True

def print_hand(hand, name='ゲスト'):
    hands = ['グー', 'チョキ', 'パー']
    print(name + 'は' + hands[hand] + 'を出しました')

# 関数 judge を定義してください
def judge(player, computer) :
    
    if player == computer :
        return '引き分け'
    
    elif player == 0 and computer == 1 :
        return '勝ち'
    
    elif player == 1 and computer == 2 :
        return '勝ち'
    
    elif player == 2 and computer == 0 :
        return '勝ち'
        
    else :
        return '負け'

print('じゃんけんをはじめます')
player_name = input('名前を入力してください：')

print('何を出しますか？（0: グー, 1: チョキ, 2: パー）')
player_hand = int(input('数字で入力してください：'))

if validate(player_hand):
    computer_hand = 1
   
    if player_name == '':
        print_hand(player_hand)
    else:
        print_hand(player_hand, player_name)
    
    print_hand(computer_hand, 'コンピューター')
    
    # 変数 result に関数 judge の戻り値を代入してください
    result = judge(player_hand, computer_hand)
    # 変数 result を出力してください
    print('結果は'+ result +'でした')
    
else:
    print('正しい数値を入力してください')




---------------------------------------------------------------------------------------------------------------------------------------

< モジュールを使おう >

コードを分けよう(コード・スプリッティング)

script.pyのコードが増えてきました。

コードが増えて長くなると、コードを読みにくくなったり何をしているか分かりづらくなったりして、予期しないバグを引き起こしやすくなります。

そこで、ここではコードを分ける方法を学んでいきましょう。


「モジュール」とは、Pythonのコードが書かれたファイルのことです。

別ファイルをモジュールとして読み込むことでそこに書かれたコードを利用することができます。

今までコードを記述していた「script.py」もモジュールです。

ここでは関数の定義部分をscript.pyからutils.pyに移します。


モジュールを使おう

「import」

importを使うことでモジュールを読み込むことができます。

モジュールを読み込んで使いたいファイルに、

「 import モジュール名 」

と書くことで読み込むことができます。

モジュール名はファイル名から拡張子（.py）を取り除いたものとなります。


モジュールの使い方

読み込んだモジュールを使ってみましょう。

「 モジュール名.関数名() 」

と書くことで、モジュール内の関数を実行することができます。

引数がある場合、関数を使用するときと同様に()のなかに書きます。


---------------------------------------------------------------------------------------------------------------------------------------
< じゃんけんゲームをコードスプリッティングする！ >

< ① script.pyファイル >

# utils.py をモジュールとして読み込んでください
import utils

print('じゃんけんをはじめます')
player_name = input('名前を入力してください：')
print('何を出しますか？（0: グー, 1: チョキ, 2: パー）')
player_hand = int(input('数字で入力してください：'))

# utils モジュール内の関数 validate を呼び出してください
if utils.validate(player_hand):
    computer_hand = 1

    if player_name == '':
        # utils モジュール内の関数 print_hand を呼び出してください
        utils.print_hand(player_hand)
    else:
        # utils モジュール内の関数 print_hand を呼び出してください
        utils.print_hand(player_hand, player_name)

    # utils モジュール内の関数 print_hand を呼び出してください
    utils.print_hand(computer_hand, 'コンピュータ')
    
    # utils モジュール内の関数 judge を呼び出してください
    result = utils.judge(player_hand, computer_hand)
    print('結果は' + result + 'でした')
else:
    print('正しい数値を入力してください')


< ② utils.pyファイル >

def validate(hand):
    if hand < 0 or hand > 2:
        return False
    return True

def print_hand(hand, name='ゲスト'):
    hands = ['グー', 'チョキ', 'パー']
    print(name + 'は' + hands[hand] + 'を出しました')

def judge(player, computer):
    if player == computer:
        return '引き分け'
    elif player == 0 and computer == 1:
        return '勝ち'
    elif player == 1 and computer == 2:
        return '勝ち'
    elif player == 2 and computer == 0:
        return '勝ち'
    else:
        return '負け'

---------------------------------------------------------------------------------------------------------------------------------------

< ライブラリ >

Pythonのビルドインオブジェクト・組み込み関数・標準ライブラリ

最初から搭載されている機能

importを使って、読み込んでから利用する！


mathライブラリ

randomライブラリ

datetimeライブラリ

---------------------------------------------------------------------------------------------------------------------------------------

< randomモジュール >

ここではrandomモジュールに用意されている関数randintを用いて、コンピュータの出す手がランダムになるようにしましょう。

randomモジュールは下図のように読み込みます。

random.randint(x, y)と書くことで、xからyまでの整数をランダムに取得することができます。




---------------------------------------------------------------------------------------------------------------------------------------



import utils
# random モジュールを読み込んでください
import random

print('じゃんけんをはじめます')
player_name = input('名前を入力してください：')
print('何を出しますか？（0: グー, 1: チョキ, 2: パー）')
player_hand = int(input('数字で入力してください：'))

if utils.validate(player_hand):
    # randint を用いて 0 から 2 までの数値を取得し、変数 computer_hand に代入してください
    computer_hand = random.randint(0,2)
    
    if player_name == '':
        utils.print_hand(player_hand)
    else:
        utils.print_hand(player_hand, player_name)

    utils.print_hand(computer_hand, 'コンピューター')
    
    result = utils.judge(player_hand, computer_hand)
    print('結果は' + result + 'でした')
else:
    print('正しい数値を入力してください')



def validate(hand):
    if hand < 0 or hand > 2:
        return False
    return True

def print_hand(hand, name='ゲスト'):
    hands = ['グー', 'チョキ', 'パー']
    print(name + 'は' + hands[hand] + 'を出しました')

def judge(player, computer):
    if player == computer:
        return '引き分け'
    elif player == 0 and computer == 1:
        return '勝ち'
    elif player == 1 and computer == 2:
        return '勝ち'
    elif player == 2 and computer == 0:
        return '勝ち'
    else:
        return '負け'


---------------------------------------------------------------------------------------------------------------------------------------

< クラスの作成とインスタンスの生成 >

クラスの定義

「もの」を生成する仕組み

プログラミングでメニューという「もの」を生成するには、まずその「設計図」を用意する必要があります。

① 「設計図」のことを「クラス」

② 「もの」のことを「インスタンス」(実体・もの)


インスタンスを生成するステップ

1. クラス(設計図)を生成する！

2. インスタンス(実体・もの)を生成する！

3. インスタンスに情報を追加する！


① クラス(設計図)を生成する！
  インスタンスは、以下の画像の流れに沿って生成していきます。
  まずは、step1の「クラスを用意する」から順番に進めていきましょう。

  class Robotama :
      # 処理


  class Robotama :
      pass (何も処理がないことを表す)


② インスタンスの生成

  Robotama() => Robotamaインスタンスを生成！

  「 クラス名() 」とそのクラスを呼び出すことで、クラス（設計図）を用いて新しくインスタンスを生成することができます。

  また、「変数名 = クラス名()」とすることで、生成したインスタンスを変数に代入することができます。

  robotama = Robotama() => Robotamaインスタンスを変数robotamaに代入！


③ インスタンスに情報を追加する！

「 インスタンス変数 」

「 menu_item1.name = 'サンドイッチ' 」とすることで、

menu_item1に「name」が「サンドイッチ」であるという情報を追加することができます。

この時、「name」のことを「インスタンス変数」と呼びますので覚えておきましょう。


インスタンス変数を用いる

また、「インスタンス.インスタンス変数名」とすることで、そのインスタンス変数の値を用いることができます。



class MenuItem:
    pass


menu_item1 = MenuItem()

menu_item1.name = 'サンドイッチ'
print(menu_item1.name)

menu_item1.price = 500
print(menu_item1.price)

---------------------------------------------------------------------------------------------------------------------------------------

< クラスとメソッド >

クラスの中に処理を追加する

クラスの中では関数を定義することができます。クラスの中で定義した関数のことをメソッドと呼びます。

メソッドの定義の方法は通常の関数と同じですが、第1引数に「 self 」を追加する必要があることに注意しましょう。

クラスの中で定義したメソッドを呼び出す

クラスの中で定義したメソッドは、インスタンスに対して使うように呼び出します。

具体的には、「インスタンス.メソッド名()」とすることで、そのメソッドを呼び出すことができます。

class MenuItem:
    # info メソッドを定義してください
    def info(self) :
        print('メニューの名前と値段が表示されます')



クラスの中で定義し、インスタンスに対して呼び出すメソッドのことを、

「インスタンスメソッド」と呼ぶので覚えておこう。

実はインスタンスメソッドでは、引数に指定した「self」に、呼び出したインスタンス自身が代入されている！

インスタンスメソッドのselfの正体

インスタンスメソッドの第1引数に指定した「self」には、そのメソッドを呼び出したインスタンス自身が代入されています。

そのため、下の図のようにメソッド内で「self.name」とすることで、そのメソッドを呼び出している「menu_item1」の「name」の値を取得することができます。

型変換の復習

今回は「name」と「price」の値を用いて、「サンドイッチ: ¥500」と出力してみましょう。

この時、「price」の値は数値型であるため、文字列と結合するためには文字列型に変換する必要があります。

下の図で、数値を文字列に変換する方法を復習してみましょう。


class MenuItem:
    def info(self):
        # 「 ○○: ¥□□ 」となるように出力してください
        print( self.name +': ¥'+ str(self.price) )


menu_item1 = MenuItem()
menu_item1.name = 'サンドイッチ'
menu_item1.price = 500

menu_item1.info()

menu_item2 = MenuItem()
menu_item2.name = 'チョコケーキ'
menu_item2.price = 400

menu_item2.info()



インスタンスメソッド（引数）

クラスとインスタンスをおさらいしよう

ここで一度、クラスとインスタンスについておさらいしましょう。

クラスは設計図のようなもので、その設計図からつくる実際の「もの」にあたるものがインスタンスです。

インスタンスは情報として「インスタンス変数」を、処理として「インスタンスメソッド」を持っています。


---------------------------------------------------------------------------------------------------------------------------------------

< __init__メソッド >

インスタンスを生成した直後に処理を実行することができる、「 __init__メソッド 」というものを学びましょう。

__init__メソッドは、「クラス名()」でインスタンスを生成した直後に自動で呼び出されます。

class MenuItem:
    # __init__ メソッドを定義してください
    def __init__(self) :
        print('MenuItemクラスのインスタンスが生成されました！')


__init__メソッドの中で、インスタンス変数に値を代入してみましょう。

インスタンスメソッドの中では、「self.変数名」でインスタンス変数を扱うことができるので、「self.変数名 = 値」でインスタンス変数に値を代入できます。


__init__メソッドの引数

__init__メソッドは通常のインスタンスメソッドと同じように、引数を受け取ることもできます。

その際、インスタンスを生成している「クラス名()」に対して引数を渡すことで、__init__メソッドにその値を渡すことができます。

class MenuItem:
    # 引数 name と price を受け取るようにしてください
    def __init__(self, name, price):
        # 「 サンドイッチ 」の代わりに引数 name の値を代入してください
        self.name = name
        
        # 500 の代わりに引数 price の値を代入してください
        self.price = price

    def info(self):
        return self.name + ': ¥' + str(self.price)

    def get_total_price(self, count):
        total_price = self.price * count
        return total_price


# 引数を「 サンドイッチ 」と 500 としてください
menu_item1 = MenuItem('サンドイッチ', 500)

print(menu_item1.info())

result = menu_item1.get_total_price(4)
print('合計は' + str(result) + '円です')


---------------------------------------------------------------------------------------------------------------------------------------

< ファイルの分割・モジュール化 >

Pythonではコードの一部を別ファイルに移して、モジュールとして読み込むことができます。

モジュールを読み込むには「import モジュール名（ファイル名）」とすることを思い出しましょう。


クラスを直接読み込む

左の図のように、「from モジュール名 import クラス名」とすることで、そのモジュール内の指定したクラスを直接読み込むことができます。

このようにすることで、「script.py」内でも今までと同じようにMenuItemクラスを用いることができます。


別ファイル内のクラスを読み込むには、以下のようなコードを書きます。
from モジュール名 import クラス名
モジュール名とはファイル名のことです。「.py」の部分は不要ですので、今回はfrom menu_itemとなります。


# menu_item.py から MenuItem クラスを読み込んでください
from menu_item import MenuItem 

menu_item1 = MenuItem('サンドイッチ', 500)




class MenuItem:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def info(self):
        return self.name + ': ¥' + str(self.price)

    def get_total_price(self, count):
        total_price = self.price * count
        return total_price


from menu_item import MenuItem

menu_item1 = MenuItem('サンドイッチ', 500)
menu_item2 = MenuItem('チョコケーキ', 400)
menu_item3 = MenuItem('コーヒー', 300)
menu_item4 = MenuItem('オレンジジュース', 200)

# 指定されたリストを変数 menu_items に代入してください
menu_items = [ menu_item1, menu_item2, menu_item3, menu_item4 ]

# for 文を作成してください
for item in menu_items :
    print( item.info() )


配列に対してfor文を用いる場合には、以下のように書きます。

「 for 変数 in 配列: 」

今回は「変数」の部分をitem、「配列」の部分をmenu_itemsとしましょう。


---------------------------------------------------------------------------------------------------------------------------------------

< 継承 >

継承とは？

既存のクラスを活用する

それでは新たにFoodクラスとDrinkクラスをつくっていきましょう。

1から新たにつくることもできますが、すでにあるMenuItemクラスを利用して、それをもとにFoodクラスとDrinkクラスをつくることができます。

そうすることで、共通部分をまとめることができ、効率的にコードを書くことができます。


# from と import を用いて、 MenuItem クラスを読み込んでください
from menu_item import MenuItem

# MenuItem クラスを継承して、 Food クラスを定義してください
class Food(MenuItem) :
    pass



継承すると親クラスのメソッドをそのまま使用することができる！


今回は左の図のように、Foodクラス内に「calorie_info」メソッドを追加してみましょう。

子クラスは「親クラス内に定義されているメソッド」と「独自に定義したメソッド」の両方が使えるということを覚えておきましょう。

また、親クラスでは子クラスのメソッドは使えません。

---------------------------------------------------------------------------------------------------------------------------------------

< オーバーライド >

親クラスにあるメソッドと同じ名前のメソッドを子クラスで定義すると、メソッドを上書きすることができます。

これをメソッドの「オーバーライド」(上書き)と呼びます。

オーバーライドをすると、子クラスのインスタンスは親クラスのメソッドではなく、子クラスで定義したメソッドを呼び出すようになります。

子クラスと親クラスに同名のメソッドがある場合は、メソッドの内容が上書きされたようになります。


__init__メソッドのオーバーライド

今回はFoodクラス内で、MenuItemクラスの__init__メソッドを上書きしてみましょう。

オーバーライドする場合には、引数の数などを変えることも可能です


class Food(MenuItem):
    # __init__ メソッドを定義してください
    def __init__(self, name, price, calorie) :
        self.name = name
        self.price = price
        self.calorie = calorie


# Food() に引数を追加してください
food1 = Food('サンドイッチ', 500, 330)


「 super() 」

オーバーライドしたメソッドの中で「super()」とすることで、親クラスを呼び出すことができます。

また「 super().メソッド名() 」とすることで、

親クラス内に定義されたインスタンスメソッドをそのまま利用することが可能です。

# 子クラス
class Food(MenuItem):
    def __init__(self, name, price, calorie):
        # super() を用いて、親クラスの __init__() を呼び出してください
        super().__init__(name, price)
        
        self.calorie = calorie

# 親クラス
class MenuItem:
    def __init__(self, name, price):
        self.name = name
        self.price = price




